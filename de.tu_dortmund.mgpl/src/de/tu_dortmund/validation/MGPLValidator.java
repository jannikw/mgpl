/*
 * generated by Xtext 2.20.0
 */
package de.tu_dortmund.validation;

import java.util.Optional;
import java.util.stream.Collectors;

import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;

import de.tu_dortmund.mGPL.AnimBlock;
import de.tu_dortmund.mGPL.AnimTarget;
import de.tu_dortmund.mGPL.ArrayVarDecl;
import de.tu_dortmund.mGPL.Assignment;
import de.tu_dortmund.mGPL.AttrAss;
import de.tu_dortmund.mGPL.AttrAssList;
import de.tu_dortmund.mGPL.BinaryExpr;
import de.tu_dortmund.mGPL.Expr;
import de.tu_dortmund.mGPL.NumberExpr;
import de.tu_dortmund.mGPL.ObjArrayDecl;
import de.tu_dortmund.mGPL.ObjDecl;
import de.tu_dortmund.mGPL.ObjType;
import de.tu_dortmund.mGPL.Program;
import de.tu_dortmund.mGPL.ReferenceTarget;
import de.tu_dortmund.mGPL.ScalarVarDecl;
import de.tu_dortmund.mGPL.TouchExpr;
import de.tu_dortmund.mGPL.UnaryExpr;
import de.tu_dortmund.mGPL.Var;
import de.tu_dortmund.mGPL.VarExpr;

/**
 * This class contains custom validation rules.
 *
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class MGPLValidator extends AbstractMGPLValidator {
	@Check
	public void checkProgramAttributes(Program program) {
		AttrAssList attributes = program.getAttributes();
		if (attributes != null) {
			EList<AttrAss> assignments = attributes.getAssignments();

			// Check existence of attributes
			assignments.stream() //
					.filter(attrAss -> !Type.GAME.hasAttr(attrAss.getAttributeName())) //
					.forEach(attrAss -> {
						error("The attribute '" + attrAss.getAttributeName() + "' does not exist for a game.", attrAss,
								program.eContainingFeature());
					});

			// Check attribute values are constants
			for (AttrAss assignment : assignments) {
				if (!isConstant(assignment.getValue())) {
					error("Attributes of game must be asigned constant values", attributes.eContainer(),
							attributes.eContainingFeature());
				}
			}

			// Check speed is set to value between 0 and 100
			Optional<AttrAss> speedAss = assignments.stream() //
					.filter(ass -> ass.getAttributeName().equals("speed")).findFirst();
			speedAss.ifPresent(ass -> {
				if (ass.getValue() instanceof NumberExpr) {
					NumberExpr number = (NumberExpr) ass.getValue();

					if (number.getNumber() < 0 || number.getNumber() > 100) {
						error("Game speed must be set between 0 and 100", attributes.eContainer(),
								attributes.eContainingFeature());
					}
				}
			});
		}
	}

	// Check attributes accessed of a variable do exist
	@Check
	public void checkAttributeAccesses(Var var) {
		if (var.getAttribute() != null) {
			Type type = getVariableType(var, true, false);

			if (!type.hasAttr(var.getAttribute())) {
				error("The type " + type + " has no attribute named '" + var.getAttribute() + "'", var.eContainer(),
						var.eContainingFeature());
			}

		}
	}

	@Check
	public void checkIndices(Var var) {
		if (var.getIndex() != null) {
			// Check index expression actually operates on array type
			Type varType = getVariableType(var, false, false);
			if (!varType.isIndexable()) {
				error("Cannot index non array variable", var.eContainer(), var.eContainingFeature());
				return;
			}

			// Check used index is an integer expression
			Type indexType = getExpressionType(var.getIndex());
			if (indexType != Type.INTEGER) {
				error("The index must be an integer expression", var.getIndex().eContainer(),
						var.getIndex().eContainingFeature());
			}
		}
	}

	@Check
	public void checkObjDecl(ObjDecl objDecl) {
		Type type = getTypeOfObj(objDecl.getType());
		AttrAssList attributes = objDecl.getAttributes();
		if (attributes != null) {
			EList<AttrAss> assignments = attributes.getAssignments();

			// Check the specific attribute actually exists fot the respective object type
			assignments.stream() //
					.filter(attrAss -> !type.hasAttr(attrAss.getAttributeName())) //
					.forEach(attrAss -> {
						error("The attribute '" + attrAss.getAttributeName() + "' does not exist for an object of type "
								+ type, attributes.eContainer(), attributes.eContainingFeature());
					});
		}
	}

	@Check
	public void checkAttrAssListUnique(AttrAssList attrs) {
		// Check each attribute is assigned at max once
		// Hacky way: each first character should only be used once
		boolean allUnique = attrs.getAssignments().stream() //
				.collect(Collectors.toMap(ass -> ass.getAttributeName().charAt(0), //
						ass -> 1, //
						(a, b) -> a + b)) //
				.values().stream() //
				.allMatch(count -> count == 1);

		if (!allUnique) {
			error("Each attributes can only be assigned once.", attrs.eContainer(), attrs.eContainingFeature());
		}
	}

	// Check the value expressions actually matches the variable's type
	@Check
	public void checkAssignments(Assignment assignment) {
		Type varType = getVariableType(assignment.getVar(), true, true);
		Type valueType = getExpressionType(assignment.getValue());

		if (varType != valueType) {
			error("Expected right hand side to be of type " + varType + " but is " + valueType,
					assignment.getValue().eContainingFeature());
		}
	}

	// Check both sides of binary expressions are integers
	// (touches is not considered a binary expression here...)
	@Check
	public void checkBinaryExprTypes(BinaryExpr expr) {
		Expr left = expr.getLeft();
		Expr right = expr.getRight();
		Type leftType = getExpressionType(left);
		Type rightType = getExpressionType(right);

		if (leftType != Type.INTEGER) {
			error("Left hand side of " + expr.getOp() + " expression must be an integer expression", expr.eContainer(),
					expr.eContainingFeature());
		}

		if (rightType != Type.INTEGER) {
			error("Right hand side of " + expr.getOp() + " expression must be an integer expression", expr.eContainer(),
					expr.eContainingFeature());
		}
	}

	// Check the operand of all unary expressions are integers
	@Check
	public void checkUnaryExprType(UnaryExpr expr) {
		Type operandType = getExpressionType(expr.getOperand());

		if (operandType != Type.INTEGER) {
			error("Operand of unary expression " + expr.getOp() + " must be an integer expression", expr.eContainer(),
					expr.eContainingFeature());
		}
	}

	// Check both sides of a touches expression are graphical objects
	@Check
	public void checkTouchesExprTypes(TouchExpr expr) {
		VarExpr toucher = expr.getToucher();
		VarExpr touchee = expr.getTouchee();

		if (!getExpressionType(toucher).isTouchable()) {
			error("Left hand side of touches expression must be a graphic object", expr.eContainer(),
					expr.eContainingFeature());
		}

		if (!getExpressionType(touchee).isTouchable()) {
			error("Right hand side of touches expression must be a graphic object", expr.eContainer(),
					expr.eContainingFeature());
		}
	}

	private boolean isConstant(Expr expr) {
		if (expr instanceof NumberExpr) {
			return true;
		}

		// Could allow constant arithmetic aswell,
		// but makes determing game speed attribute's value harder...
//		if (expr instanceof BinaryExpr) {
//			return true;
//		}
//
//		if (expr instanceof UnaryExpr) {
//			return true;
//		}

		return false;
	}

	/**
	 * Determines the type of a referenced variable
	 * 
	 * @param var       the variable (included optional index and attribute)
	 * @param withIndex include index when determining type?
	 * @param withAttr  include attribute when determining type?
	 * @return the type
	 */
	private Type getVariableType(Var var, boolean withIndex, boolean withAttr) {
		ReferenceTarget variableTarget = var.getVariable();

		if (variableTarget instanceof Program) {
			if (var.getAttribute() != null && withAttr) {
				return getAttrType(var.getAttribute());
			}

			return Type.GAME;
		}

		if (variableTarget instanceof AnimTarget) {
			AnimTarget target = (AnimTarget) variableTarget;
			if (var.getAttribute() != null && withAttr) {
				return getAttrType(var.getAttribute());
			}

			return getTypeOfObj(target.getType());
		}

		if (variableTarget instanceof ScalarVarDecl) {
			return Type.INTEGER;
		}

		if (variableTarget instanceof ArrayVarDecl) {
			if (var.getIndex() != null && withIndex) {
				return Type.INTEGER;
			}

			return Type.INTEGER_ARRAY;
		}

		if (variableTarget instanceof ObjDecl) {
			ObjDecl objDecl = (ObjDecl) variableTarget;
			if (var.getAttribute() != null && withAttr) {
				return getAttrType(var.getAttribute());
			}

			return getTypeOfObj(objDecl.getType());
		}

		if (variableTarget instanceof ObjArrayDecl) {
			ObjArrayDecl objArrayDecl = (ObjArrayDecl) variableTarget;
			if (var.getIndex() != null && withIndex) {
				if (var.getAttribute() != null && withAttr) {
					return getAttrType(var.getAttribute());
				}

				return getTypeOfObj(((ObjArrayDecl) variableTarget).getType());
			}

			switch (objArrayDecl.getType()) {
			case CIRCLE:
				return Type.CIRCLE_ARRAY;
			case RECTANGLE:
				return Type.RECTANGLE_ARRAY;
			case TRIANGLE:
				return Type.TRIANGLE_ARRAY;
			}
		}

		if (variableTarget instanceof AnimBlock) {
			return Type.ANIMATION_HANDLER;
		}

		throw new IllegalArgumentException("Unknown variable type");
	}

	// Convert ObjType to Type enum
	private Type getTypeOfObj(ObjType objType) {
		switch (objType) {
		case CIRCLE:
			return Type.CIRCLE;
		case RECTANGLE:
			return Type.RECTANGLE;
		case TRIANGLE:
			return Type.TRIANGLE;
		}

		throw new IllegalArgumentException();
	}

	// Get type of attribute, all attributes are integers except for animation_block
	private Type getAttrType(String attr) {
		if (attr.equals("animation_block")) {
			return Type.ANIMATION_HANDLER;
		}

		return Type.INTEGER;
	}

	// Determine the resulting type of an expression
	private Type getExpressionType(Expr expr) {
		if (expr instanceof BinaryExpr) {
			return Type.INTEGER;
		}

		if (expr instanceof UnaryExpr) {
			return Type.INTEGER;
		}

		if (expr instanceof NumberExpr) {
			return Type.INTEGER;
		}

		if (expr instanceof TouchExpr) {
			return Type.INTEGER;
		}

		if (expr instanceof VarExpr) {
			VarExpr varExpr = (VarExpr) expr;
			Var var = varExpr.getVar();
			return getVariableType(var, true, true);
		}

		error("Unknown variable referenced", expr.eContainer(), expr.eContainingFeature());

		throw new IllegalArgumentException("Unknown expression type: " + expr.getClass());
	}

}
