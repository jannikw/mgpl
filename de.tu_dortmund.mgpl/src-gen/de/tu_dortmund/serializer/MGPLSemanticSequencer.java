/*
 * generated by Xtext 2.20.0
 */
package de.tu_dortmund.serializer;

import com.google.inject.Inject;
import de.tu_dortmund.mGPL.AnimBlock;
import de.tu_dortmund.mGPL.AnimTarget;
import de.tu_dortmund.mGPL.ArrayVarDecl;
import de.tu_dortmund.mGPL.Assignment;
import de.tu_dortmund.mGPL.AttrAss;
import de.tu_dortmund.mGPL.AttrAssList;
import de.tu_dortmund.mGPL.BinaryExpr;
import de.tu_dortmund.mGPL.EventBlock;
import de.tu_dortmund.mGPL.ForStmt;
import de.tu_dortmund.mGPL.IfStmt;
import de.tu_dortmund.mGPL.MGPLPackage;
import de.tu_dortmund.mGPL.NumberExpr;
import de.tu_dortmund.mGPL.ObjArrayDecl;
import de.tu_dortmund.mGPL.ObjDecl;
import de.tu_dortmund.mGPL.Program;
import de.tu_dortmund.mGPL.ScalarVarDecl;
import de.tu_dortmund.mGPL.StmtBlock;
import de.tu_dortmund.mGPL.TouchExpr;
import de.tu_dortmund.mGPL.UnaryExpr;
import de.tu_dortmund.mGPL.Var;
import de.tu_dortmund.mGPL.VarExpr;
import de.tu_dortmund.services.MGPLGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MGPLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MGPLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MGPLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MGPLPackage.ANIM_BLOCK:
				sequence_AnimBlock(context, (AnimBlock) semanticObject); 
				return; 
			case MGPLPackage.ANIM_TARGET:
				sequence_AnimTarget(context, (AnimTarget) semanticObject); 
				return; 
			case MGPLPackage.ARRAY_VAR_DECL:
				sequence_ArrayVarDecl(context, (ArrayVarDecl) semanticObject); 
				return; 
			case MGPLPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case MGPLPackage.ATTR_ASS:
				sequence_AttrAss(context, (AttrAss) semanticObject); 
				return; 
			case MGPLPackage.ATTR_ASS_LIST:
				sequence_AttrAssList(context, (AttrAssList) semanticObject); 
				return; 
			case MGPLPackage.BINARY_EXPR:
				sequence_AddExpr_BoolExpr_MulExpr_OrExpr_RelExpr(context, (BinaryExpr) semanticObject); 
				return; 
			case MGPLPackage.EVENT_BLOCK:
				sequence_EventBlock(context, (EventBlock) semanticObject); 
				return; 
			case MGPLPackage.FOR_STMT:
				sequence_ForStmt(context, (ForStmt) semanticObject); 
				return; 
			case MGPLPackage.IF_STMT:
				sequence_IfStmt(context, (IfStmt) semanticObject); 
				return; 
			case MGPLPackage.NUMBER_EXPR:
				sequence_NumberExpr(context, (NumberExpr) semanticObject); 
				return; 
			case MGPLPackage.OBJ_ARRAY_DECL:
				sequence_ObjArrayDecl(context, (ObjArrayDecl) semanticObject); 
				return; 
			case MGPLPackage.OBJ_DECL:
				sequence_ObjDecl(context, (ObjDecl) semanticObject); 
				return; 
			case MGPLPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case MGPLPackage.SCALAR_VAR_DECL:
				sequence_ScalarVarDecl(context, (ScalarVarDecl) semanticObject); 
				return; 
			case MGPLPackage.STMT_BLOCK:
				sequence_StmtBlock(context, (StmtBlock) semanticObject); 
				return; 
			case MGPLPackage.TOUCH_EXPR:
				sequence_SimpleExpr(context, (TouchExpr) semanticObject); 
				return; 
			case MGPLPackage.UNARY_EXPR:
				sequence_UnaryExpr(context, (UnaryExpr) semanticObject); 
				return; 
			case MGPLPackage.VAR:
				sequence_Var(context, (Var) semanticObject); 
				return; 
			case MGPLPackage.VAR_EXPR:
				sequence_VarExpr(context, (VarExpr) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expr returns BinaryExpr
	 *     OrExpr returns BinaryExpr
	 *     OrExpr.BinaryExpr_1_0 returns BinaryExpr
	 *     BoolExpr returns BinaryExpr
	 *     BoolExpr.BinaryExpr_1_0 returns BinaryExpr
	 *     RelExpr returns BinaryExpr
	 *     RelExpr.BinaryExpr_1_0 returns BinaryExpr
	 *     AddExpr returns BinaryExpr
	 *     AddExpr.BinaryExpr_1_0 returns BinaryExpr
	 *     MulExpr returns BinaryExpr
	 *     MulExpr.BinaryExpr_1_0 returns BinaryExpr
	 *     SimpleExpr returns BinaryExpr
	 *
	 * Constraint:
	 *     (
	 *         (left=OrExpr_BinaryExpr_1_0 op='||' right=BoolExpr) | 
	 *         (left=BoolExpr_BinaryExpr_1_0 op='&&' right=RelExpr) | 
	 *         (left=RelExpr_BinaryExpr_1_0 (op='==' | op='<' | op='<=') right=AddExpr) | 
	 *         (left=AddExpr_BinaryExpr_1_0 (op='+' | op='-') right=MulExpr) | 
	 *         (left=MulExpr_BinaryExpr_1_0 (op='*' | op='/') right=SimpleExpr)
	 *     )
	 */
	protected void sequence_AddExpr_BoolExpr_MulExpr_OrExpr_RelExpr(ISerializationContext context, BinaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReferenceTarget returns AnimBlock
	 *     Block returns AnimBlock
	 *     AnimBlock returns AnimBlock
	 *
	 * Constraint:
	 *     (name=IDF target=AnimTarget action=StmtBlock)
	 */
	protected void sequence_AnimBlock(ISerializationContext context, AnimBlock semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.REFERENCE_TARGET__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.REFERENCE_TARGET__NAME));
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.ANIM_BLOCK__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.ANIM_BLOCK__TARGET));
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.BLOCK__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.BLOCK__ACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnimBlockAccess().getNameIDFTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAnimBlockAccess().getTargetAnimTargetParserRuleCall_3_0(), semanticObject.getTarget());
		feeder.accept(grammarAccess.getAnimBlockAccess().getActionStmtBlockParserRuleCall_5_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ReferenceTarget returns AnimTarget
	 *     AnimTarget returns AnimTarget
	 *
	 * Constraint:
	 *     (type=ObjType name=IDF)
	 */
	protected void sequence_AnimTarget(ISerializationContext context, AnimTarget semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.ANIM_TARGET__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.ANIM_TARGET__TYPE));
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.REFERENCE_TARGET__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.REFERENCE_TARGET__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnimTargetAccess().getTypeObjTypeEnumRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getAnimTargetAccess().getNameIDFTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ReferenceTarget returns ArrayVarDecl
	 *     Decl returns ArrayVarDecl
	 *     VarDecl returns ArrayVarDecl
	 *     ArrayVarDecl returns ArrayVarDecl
	 *
	 * Constraint:
	 *     (name=IDF size=INT)
	 */
	protected void sequence_ArrayVarDecl(ISerializationContext context, ArrayVarDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.REFERENCE_TARGET__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.REFERENCE_TARGET__NAME));
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.ARRAY_VAR_DECL__SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.ARRAY_VAR_DECL__SIZE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayVarDeclAccess().getNameIDFTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getArrayVarDeclAccess().getSizeINTTerminalRuleCall_3_0(), semanticObject.getSize());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns Assignment
	 *     Assignment returns Assignment
	 *     AssStmt returns Assignment
	 *
	 * Constraint:
	 *     (var=Var value=Expr)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.ASSIGNMENT__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.ASSIGNMENT__VAR));
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getVarVarParserRuleCall_0_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getAssignmentAccess().getValueExprParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttrAssList returns AttrAssList
	 *
	 * Constraint:
	 *     (assignments+=AttrAss assignments+=AttrAss*)
	 */
	protected void sequence_AttrAssList(ISerializationContext context, AttrAssList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttrAss returns AttrAss
	 *
	 * Constraint:
	 *     (attributeName=IDF value=Expr)
	 */
	protected void sequence_AttrAss(ISerializationContext context, AttrAss semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.ATTR_ASS__ATTRIBUTE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.ATTR_ASS__ATTRIBUTE_NAME));
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.ATTR_ASS__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.ATTR_ASS__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttrAssAccess().getAttributeNameIDFTerminalRuleCall_0_0(), semanticObject.getAttributeName());
		feeder.accept(grammarAccess.getAttrAssAccess().getValueExprParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Block returns EventBlock
	 *     EventBlock returns EventBlock
	 *
	 * Constraint:
	 *     (key=KeyStroke action=StmtBlock)
	 */
	protected void sequence_EventBlock(ISerializationContext context, EventBlock semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.EVENT_BLOCK__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.EVENT_BLOCK__KEY));
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.BLOCK__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.BLOCK__ACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEventBlockAccess().getKeyKeyStrokeEnumRuleCall_1_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getEventBlockAccess().getActionStmtBlockParserRuleCall_2_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns ForStmt
	 *     ForStmt returns ForStmt
	 *
	 * Constraint:
	 *     (init=Assignment condition=Expr step=Assignment body=StmtBlock)
	 */
	protected void sequence_ForStmt(ISerializationContext context, ForStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.FOR_STMT__INIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.FOR_STMT__INIT));
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.FOR_STMT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.FOR_STMT__CONDITION));
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.FOR_STMT__STEP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.FOR_STMT__STEP));
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.FOR_STMT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.FOR_STMT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForStmtAccess().getInitAssignmentParserRuleCall_2_0(), semanticObject.getInit());
		feeder.accept(grammarAccess.getForStmtAccess().getConditionExprParserRuleCall_4_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getForStmtAccess().getStepAssignmentParserRuleCall_6_0(), semanticObject.getStep());
		feeder.accept(grammarAccess.getForStmtAccess().getBodyStmtBlockParserRuleCall_8_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns IfStmt
	 *     IfStmt returns IfStmt
	 *
	 * Constraint:
	 *     (condition=Expr then=StmtBlock else=StmtBlock?)
	 */
	protected void sequence_IfStmt(ISerializationContext context, IfStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns NumberExpr
	 *     OrExpr returns NumberExpr
	 *     OrExpr.BinaryExpr_1_0 returns NumberExpr
	 *     BoolExpr returns NumberExpr
	 *     BoolExpr.BinaryExpr_1_0 returns NumberExpr
	 *     RelExpr returns NumberExpr
	 *     RelExpr.BinaryExpr_1_0 returns NumberExpr
	 *     AddExpr returns NumberExpr
	 *     AddExpr.BinaryExpr_1_0 returns NumberExpr
	 *     MulExpr returns NumberExpr
	 *     MulExpr.BinaryExpr_1_0 returns NumberExpr
	 *     SimpleExpr returns NumberExpr
	 *     NumberExpr returns NumberExpr
	 *
	 * Constraint:
	 *     number=INT
	 */
	protected void sequence_NumberExpr(ISerializationContext context, NumberExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.NUMBER_EXPR__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.NUMBER_EXPR__NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberExprAccess().getNumberINTTerminalRuleCall_0(), semanticObject.getNumber());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ReferenceTarget returns ObjArrayDecl
	 *     Decl returns ObjArrayDecl
	 *     ObjArrayDecl returns ObjArrayDecl
	 *
	 * Constraint:
	 *     (type=ObjType name=IDF size=INT)
	 */
	protected void sequence_ObjArrayDecl(ISerializationContext context, ObjArrayDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.OBJ_ARRAY_DECL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.OBJ_ARRAY_DECL__TYPE));
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.REFERENCE_TARGET__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.REFERENCE_TARGET__NAME));
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.OBJ_ARRAY_DECL__SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.OBJ_ARRAY_DECL__SIZE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjArrayDeclAccess().getTypeObjTypeEnumRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getObjArrayDeclAccess().getNameIDFTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getObjArrayDeclAccess().getSizeINTTerminalRuleCall_3_0(), semanticObject.getSize());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ReferenceTarget returns ObjDecl
	 *     Decl returns ObjDecl
	 *     ObjDecl returns ObjDecl
	 *
	 * Constraint:
	 *     (type=ObjType name=IDF attributes=AttrAssList?)
	 */
	protected void sequence_ObjDecl(ISerializationContext context, ObjDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *     ReferenceTarget returns Program
	 *
	 * Constraint:
	 *     (name=IDF attributes=AttrAssList? declarations+=Decl* init=StmtBlock blocks+=Block*)
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReferenceTarget returns ScalarVarDecl
	 *     Decl returns ScalarVarDecl
	 *     VarDecl returns ScalarVarDecl
	 *     ScalarVarDecl returns ScalarVarDecl
	 *
	 * Constraint:
	 *     (name=IDF initialization=Expr?)
	 */
	protected void sequence_ScalarVarDecl(ISerializationContext context, ScalarVarDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns TouchExpr
	 *     OrExpr returns TouchExpr
	 *     OrExpr.BinaryExpr_1_0 returns TouchExpr
	 *     BoolExpr returns TouchExpr
	 *     BoolExpr.BinaryExpr_1_0 returns TouchExpr
	 *     RelExpr returns TouchExpr
	 *     RelExpr.BinaryExpr_1_0 returns TouchExpr
	 *     AddExpr returns TouchExpr
	 *     AddExpr.BinaryExpr_1_0 returns TouchExpr
	 *     MulExpr returns TouchExpr
	 *     MulExpr.BinaryExpr_1_0 returns TouchExpr
	 *     SimpleExpr returns TouchExpr
	 *
	 * Constraint:
	 *     (toucher=SimpleExpr_TouchExpr_2_1_0 touchee=VarExpr)
	 */
	protected void sequence_SimpleExpr(ISerializationContext context, TouchExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.TOUCH_EXPR__TOUCHER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.TOUCH_EXPR__TOUCHER));
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.TOUCH_EXPR__TOUCHEE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.TOUCH_EXPR__TOUCHEE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleExprAccess().getTouchExprToucherAction_2_1_0(), semanticObject.getToucher());
		feeder.accept(grammarAccess.getSimpleExprAccess().getToucheeVarExprParserRuleCall_2_1_2_0(), semanticObject.getTouchee());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StmtBlock returns StmtBlock
	 *
	 * Constraint:
	 *     statements+=Stmt*
	 */
	protected void sequence_StmtBlock(ISerializationContext context, StmtBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns UnaryExpr
	 *     OrExpr returns UnaryExpr
	 *     OrExpr.BinaryExpr_1_0 returns UnaryExpr
	 *     BoolExpr returns UnaryExpr
	 *     BoolExpr.BinaryExpr_1_0 returns UnaryExpr
	 *     RelExpr returns UnaryExpr
	 *     RelExpr.BinaryExpr_1_0 returns UnaryExpr
	 *     AddExpr returns UnaryExpr
	 *     AddExpr.BinaryExpr_1_0 returns UnaryExpr
	 *     MulExpr returns UnaryExpr
	 *     MulExpr.BinaryExpr_1_0 returns UnaryExpr
	 *     SimpleExpr returns UnaryExpr
	 *     UnaryExpr returns UnaryExpr
	 *
	 * Constraint:
	 *     ((op='-' | op='!') operand=SimpleExpr)
	 */
	protected void sequence_UnaryExpr(ISerializationContext context, UnaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns VarExpr
	 *     OrExpr returns VarExpr
	 *     OrExpr.BinaryExpr_1_0 returns VarExpr
	 *     BoolExpr returns VarExpr
	 *     BoolExpr.BinaryExpr_1_0 returns VarExpr
	 *     RelExpr returns VarExpr
	 *     RelExpr.BinaryExpr_1_0 returns VarExpr
	 *     AddExpr returns VarExpr
	 *     AddExpr.BinaryExpr_1_0 returns VarExpr
	 *     MulExpr returns VarExpr
	 *     MulExpr.BinaryExpr_1_0 returns VarExpr
	 *     SimpleExpr returns VarExpr
	 *     SimpleExpr.TouchExpr_2_1_0 returns VarExpr
	 *     VarExpr returns VarExpr
	 *
	 * Constraint:
	 *     var=Var
	 */
	protected void sequence_VarExpr(ISerializationContext context, VarExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGPLPackage.Literals.VAR_EXPR__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGPLPackage.Literals.VAR_EXPR__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarExprAccess().getVarVarParserRuleCall_0(), semanticObject.getVar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Var returns Var
	 *
	 * Constraint:
	 *     (variable=[ReferenceTarget|IDF] | (variable=[ReferenceTarget|IDF] index=Expr attribute=IDF?) | (variable=[ReferenceTarget|IDF] attribute=IDF))
	 */
	protected void sequence_Var(ISerializationContext context, Var semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
